<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
      <meta name="robots" content="noindex">

    <title>Deploying Applications | Cloud Platform User Guide</title>

    <!--[if gt IE 8]><!--><link href="/stylesheets/screen.css" rel="stylesheet" media="screen" /><!--<![endif]-->
    <!--[if lte IE 8]><link href="/stylesheets/screen-old-ie.css" rel="stylesheet" media="screen" /><![endif]-->

    <link rel="canonical" href="https://user-guide.cloud-platform.service.justice.gov.uk/deploying-applications.html">


    <link href="/stylesheets/print.css" rel="stylesheet" media="print" />
    <script src="/javascripts/application.js"></script>

      <meta property="og:image" content="https://user-guide.cloud-platform.service.justice.gov.uk/images/govuk-large.png" />
      <meta property="og:site_name" content="Cloud Platform User Guide" />
      <meta property="og:title" content="Deploying Applications" />
      <meta property="og:type" content="object" />
      <meta property="og:url" content="https://user-guide.cloud-platform.service.justice.gov.uk/deploying-applications.html" />
      <meta property="twitter:card" content="summary" />
      <meta property="twitter:domain" content="user-guide.cloud-platform.service.justice.gov.uk" />
      <meta property="twitter:image" content="https://user-guide.cloud-platform.service.justice.gov.uk/images/govuk-large.png" />
      <meta property="twitter:title" content="Deploying Applications | Cloud Platform User Guide" />
      <meta property="twitter:url" content="https://user-guide.cloud-platform.service.justice.gov.uk/deploying-applications.html" />

    
  </head>

  <body>
    <div class="app-pane">
      <div class="app-pane__header toc-open-disabled">
        <a href="#content" class="skip-link">Skip to main content</a>

        <header class="header header--full-width">
  <div class="header__container">
    <div class="header__brand">
        <a href="/">
        <span class="header__title">
          Cloud Platform User Guide
            <span class="phase-banner">INTERNAL</span>
        </span>
        </a>
    </div>

      <div data-module="navigation">
        <button type="button" class="header__navigation-toggle js-nav-toggle" aria-controls="navigation" aria-label="Show or hide top level navigation">Menu</button>

        <nav id="navigation" class="header__navigation js-nav" aria-label="Top Level Navigation" aria-hidden="true">
          <ul>
              <li>
                <a href="/">Documentation</a>
              </li>
              <li>
                <a href="https://github.com/ministryofjustice/cloud-platform-user-guide">GitHub</a>
              </li>
          </ul>
        </nav>
      </div>
  </div>
</header>

      </div>

        <div id="toc-heading" class="toc-show fixedsticky">
          <a href="#toc" class="toc-show__label js-toc-show" aria-controls="toc">
            Table of contents <span class="toc-show__icon"></span>
          </a>
        </div>

      <div class="app-pane__body" data-module="in-page-navigation">
          <div class="app-pane__toc">
            <div class="toc" data-module="table-of-contents">
              <div class="search" data-module="search">
  <form action="https://www.google.co.uk/search" method="get" role="search">
    <input type="hidden" name="as_sitesearch" value="https://user-guide.cloud-platform.service.justice.gov.uk"/>
    <label for="search"  class="search__label">Search (via Google)</label>
    <input type="text" id="search" name="q" placeholder="Search" aria-controls="search-results" class="form-control" />
  </form>
  <div id="search-results" class="search-results" aria-hidden="true" role="dialog" aria-labelledby="search-results-title">
    <div class="search-results__inner">
      <button class="search-results__close">Close<span class="search-results__close-label"> search results</span></button>
      <h2 id="search-results-title" class="search-results__title" aria-live="polite">Results</h2>
      <div class="search-results__content"></div>
    </div>
  </div>
</div>

              <a href="#" class="toc__close js-toc-close" aria-controls="toc" aria-label="Hide table of contents"></a>
              <nav id="toc" class="js-toc-list toc__list" aria-labelledby="toc-heading" data-module="collapsible-navigation">
                      <ul>
  <li>
    <a href="/#cloud-platform-user-guide">Cloud platform user guide</a>
    <ul>
      <li>
        <a href="/#cloud-platform-user-guide-overview">Overview</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/getting-started.html#getting-started">Getting Started</a>
    <ul>
      <li>
        <a href="/getting-started.html#kubectl-configuration">kubectl configuration</a>
      </li>
      <li>
        <a href="/getting-started.html#creating-a-cloud-platform-environment">Creating a Cloud Platform Environment</a>
      </li>
      <li>
        <a href="/getting-started.html#creating-an-ecr-repository">Creating an ECR repository</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/deploying-applications.html#deploying-applications">Deploying Applications</a>
    <ul>
      <li>
        <a href="/deploying-applications.html#deploying-a-39-hello-world-39-application-to-the-cloud-platform">Deploying a ‘Hello World’ application to the Cloud Platform</a>
      </li>
      <li>
        <a href="/deploying-applications.html#deploying-a-multi-container-application-to-the-cloud-platform">Deploying a multi-container application to the Cloud Platform</a>
      </li>
      <li>
        <a href="/deploying-applications.html#deploying-an-application-to-the-cloud-platform-with-helm">Deploying an application to the Cloud Platform with Helm</a>
      </li>
      <li>
        <a href="/deploying-applications.html#adding-a-secret-to-an-application">Adding a secret to an application</a>
      </li>
      <li>
        <a href="/deploying-applications.html#continuous-deployment-of-an-application-using-circleci-and-helm">Continuous Deployment of an application using CircleCI and Helm</a>
      </li>
      <li>
        <a href="/deploying-applications.html#adding-aws-resources-to-your-environment">Adding AWS resources to your environment</a>
      </li>
      <li>
        <a href="/deploying-applications.html#cleaning-up">Cleaning up</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/monitoring-applications.html#monitoring-applications">Monitoring Applications</a>
    <ul>
      <li>
        <a href="/monitoring-applications.html#using-the-cloud-platform-prometheus-alertmanager-and-grafana">Using the Cloud Platform Prometheus, AlertManager and Grafana</a>
      </li>
      <li>
        <a href="/monitoring-applications.html#creating-your-own-custom-alerts">Creating your own custom alerts</a>
      </li>
      <li>
        <a href="/monitoring-applications.html#getting-application-metrics-into-prometheus">Getting Application Metrics into Prometheus</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/other-topics.html#other-topics">Other Topics</a>
    <ul>
      <li>
        <a href="/other-topics.html#git-crypt">Git-Crypt</a>
      </li>
      <li>
        <a href="/other-topics.html#secrets-overview">Secrets overview</a>
      </li>
      <li>
        <a href="/other-topics.html#kubectl-quick-reference">Kubectl quick reference</a>
      </li>
      <li>
        <a href="/other-topics.html#how-to-access-my-log-data-using-kibana">How to access my log data using Kibana</a>
      </li>
      <li>
        <a href="/other-topics.html#kubernetes-basics-links-to-helpful-beginner-resources">Kubernetes Basics - Links to helpful beginner resources</a>
      </li>
      <li>
        <a href="/other-topics.html#cloud-platform-support">Cloud Platform Support</a>
      </li>
      <li>
        <a href="/other-topics.html#zero-downtime-deployments">Zero Downtime Deployments</a>
      </li>
      <li>
        <a href="/other-topics.html#contributing-to-this-document">Contributing to this document</a>
      </li>
      <li>
        <a href="/other-topics.html#using-an-externally-managed-hostname">Using an externally-managed hostname</a>
      </li>
      <li>
        <a href="/other-topics.html#ip-whitelisting">IP Whitelisting</a>
      </li>
      <li>
        <a href="/other-topics.html#ecr-lifecycle-policy">ECR Lifecycle Policy</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/getting-help.html#getting-help">Getting Help</a>
    <ul>
      <li>
        <a href="/getting-help.html#slack-channel">Slack Channel</a>
      </li>
      <li>
        <a href="/getting-help.html#raise-a-support-ticket">Raise a support ticket</a>
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <a href="/deprecation-warning.html#live-0-cluster-deprecation-notice">LIVE-0 CLUSTER DEPRECATION NOTICE</a>
  </li>
</ul>


              </nav>
            </div>
          </div>

        <div class="app-pane__content toc-open-disabled">
          <main id="content" class="technical-documentation" data-module="anchored-headings">
              <h1 id="deploying-applications">Deploying Applications</h1>
<p><h2 id="deploying-a-39-hello-world-39-application-to-the-cloud-platform">Deploying a &lsquo;Hello World&rsquo; application to the Cloud Platform</h2><p><a href="../images/k8s-cluster-application-deployment-process.png" target="_blank" rel="noopener noreferrer"><img src="/images/k8s-cluster-application-deployment-process.png" alt="Deployment Process Diagram" /></a></p>
<h3 id="overview">Overview</h3><p>The aim of this guide is to walkthrough the process of deploying an application into the Cloud Platform.</p>
<p>This guide uses a pre-configured <a href="https://github.com/ministryofjustice/cloud-platform-helloworld-ruby-app">&ldquo;Hello World&rdquo; application</a> as an example of how to deploy your own. This application merely returns a static HTML response, and has no dependencies. Later examples will use more representative applications.</p>
<p>The process we will follow consists of the following stages:</p></p>

<ul>
<li>Build a docker image from the demo application</li>
<li>Tag the image and push it to your ECR</li>
<li>Edit kubernetes config files</li>
<li>Apply the config files to make the cluster run our application</li>
</ul>

<p>The process of building an image and pushing it to an ECR will normally be carried out by a build pipeline. For this initial walkthrough, we will go through these steps manually. Later we will go through an example of setting up a <a href="https://circleci.com">CircleCI</a> job to do this automatically. The steps are similar if you&rsquo;re using other CI/CD tools such as <a href="https://travis-ci.org">TravisCI</a>.</p>

<h3 id="prerequisites">Prerequisites</h3><p>This guide assumes the following:</p>

<ul>
<li><a href="https://www.docker.com">Docker</a> is installed and configured.</li>
<li>Kubectl is installed and configured (<code>brew install kubectl</code> on a Mac with <a href="https://brew.sh">Homebrew</a> installed)</li>
<li>AWS CLI is installed (<code>brew install awscli</code> on a Mac with <a href="https://brew.sh">Homebrew</a> installed)</li>
<li>You have <a href="/getting-started.html#creating-a-cloud-platform-environment">created an environment for your application</a></li>
<li>You have <a href="/getting-started.html#creating-an-ecr-repository">created an Amazon ECR</a> to host your docker image</li>
</ul>
<h3 id="step-1-build-your-docker-image">Step 1 - Build your docker image</h3>

<ul>
<li><p>Clone the <a href="https://github.com/ministryofjustice/cloud-platform-helloworld-ruby-app">demo application</a></p>
<p>git clone https://github.com/ministryofjustice/cloud-platform-helloworld-ruby-app
  cd cloud-platform-helloworld-ruby-app</p></li>
<li><p>Build the docker image</p>
<p>docker build -t [ECR Team Name]/[ECR Repository Name] .</p></li>
</ul>

<p>The <code>ECR Team Name</code> and <code>ECR Repository Name</code> must match the <code>team_name</code> and <code>repo_name</code> values you entered when you created the ECR via <a href="https://github.com/ministryofjustice/cloud-platform-environments">cloud-platform-environments</a> Github repository.</p>

<p>You can find them in the file <code>namespaces/cloud-platform-live-0.k8s.integration.dsd.io/[YOUR ENVIRONMENT]/resources/ecr.tf</code>.</p>
<p><h4 id="amazon-ecr-terminology">Amazon ECR Terminology</h4><p>Amazon ECR uses the terms <code>repository</code> and <code>image</code> in a rather confusing way. Normally, you would think of a docker image repository as holding mutiple images, each with a different name, where each image can have multiple tags. Amazon ECR conflates the repository and image - i.e. you can only push images with the same name to a given ECR.</p>
<p>So, if you created your ECR using the team_name <code>davids-dummy-team</code> and repo_name <code>davids-dummy-app</code>, then you can only push images to the ECR if they are named <code>davids-dummy-team/davids-dummy-app:[something]</code>. You are free to change the tag of the image (shown as [something], here), and some teams overload the tag value as a way to store multiple completely different docker images in a single ECR.</p>
<h3 id="step-2-push-the-image-to-your-ecr">Step 2 - Push the image to your ECR</h3><h4 id="authenticating-to-your-docker-image-repository">Authenticating to your docker image repository</h4><p>You must authenticate to the docker image repository before you can push an image to it.</p>
<p>To authenticate to your ECR, you will need the <code>access_key_id</code> and <code>secret_access_key</code> which were created for you when you created your ECR. To retrieve these, see the <a href="/getting-started.html#accessing-the-credentials">this section</a> of this guide.</p>
<p><em>tl;dr</em> use this command:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl -n [namespace_name] get secret [name of your secret] -o yaml
</code></pre></div><p>Don&rsquo;t forget to base64 decode the <code>access_key_id</code> and <code>secret_access_key</code> values before using them.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  echo &#39;your_access_key_id_value&#39; | base64 --decode
</code></pre></div><p>Once you have your <code>access_key_id</code> and <code>secret_access_key</code>, set up an AWS profile using the AWS cli tool.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  aws configure
</code></pre></div><p>Supply your credentials when prompted.</p>
<p>This guide assumes you are using these credentials in your <code>default</code> AWS profile. If you have used a different name for this AWS profile, please add <code>--profile [YOUR PROFILE]</code> to all of the following AWS commands.</p>
<h4 id="authenticating-with-the-repository">Authenticating with the repository</h4><p>Use the following command to login to Amazon ECR</p>
<div class="highlight"><pre class="highlight plaintext"><code>  $(aws ecr get-login --no-include-email --region eu-west-1)
</code></pre></div><p>Note: The output of the <code>aws ecr...</code> command is a long <code>docker login...</code> command. Including the <code>$(...)</code> around the command executes this output in the context of the current shell</p>
<p>The output of the above should include <code>Login Succeeded</code> to confirm you have authenticated to the docker image repository.</p>
<p>These credential are valid for 12 hours. So, if you are working through this example over a longer period, you will have to login again, e.g. the following day.</p>
<h4 id="pushing-your-docker-image-to-the-ecr">Pushing your docker image to the ECR</h4><p>All of the MoJ Digital docker images are stored within the same Cloud Platform AWS account (mojds-platforms-integration).</p>
<p>Your specific ECR will be:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  926803513772.dkr.ecr.eu-west-1.amazonaws.com/[team_name]/[repo_name]
</code></pre></div><p>Where <code>team_name</code> and <code>repo_name</code> are the values from your <code>ecr.tf</code> file.</p>
<p>Ensure the Docker image for your application has been built and is stored locally on your machine.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  docker build -t [team_name]/[repo_name] .
</code></pre></div><p>Now we need to tag the image so it can be pushed into the correct repository.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  docker tag [team_name]/[repo_name]:latest 926803513772.dkr.ecr.eu-west-1.amazonaws.com/[team_name]/[repo_name]:latest
</code></pre></div><p>Finish by running the last command to push the image to your repository.</p>
<div class="highlight"><pre class="highlight plaintext"><code>docker push 926803513772.dkr.ecr.eu-west-1.amazonaws.com/[team_name]/[repo_name]:latest
</code></pre></div><h3 id="step-3-configure-your-namespace-in-the-kubernetes-cluster">Step 3 - Configure your namespace in the Kubernetes Cluster</h3><p>To deploy an application to the Cloud Platform, a number of deployment files must first be configured. You can find examples of these in the <code>kubectl_deploy</code> directory of the <a href="https://github.com/ministryofjustice/cloud-platform-helloworld-ruby-app">demo application</a>, but you will need to edit your copy to replace some of the values to use your kubernetes cluster environment and docker image.</p>
<p><em>Tip:</em> You can find more deployment config info <a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">in the kubernetes developer documentation</a>.</p>
<h4 id="deployment-yaml">deployment.yaml</h4><div class="highlight"><pre class="highlight plaintext"><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-rubyapp
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: helloworld-rubyapp
    spec:
      containers:
      - name: rubyapp
        image: 926803513772.dkr.ecr.eu-west-1.amazonaws.com/davids-dummy-team/davids-dummy-app:latest
        ports:
        - containerPort: 4567
</code></pre></div><p>This file tells Kubernetes to run a single pod (<code>replicas: 1</code>) containing a single container based on a specific docker image from your ECR.</p>
<p>Change the image value to refer to the image you pushed to your ECR in the earlier step.</p>
<p>The <code>service.yaml</code> and <code>ingress.yaml</code> files make it possible to access your application from the outside world.</p>
<h4 id="service-yaml">service.yaml</h4><p>Service files are used to specify port and protocol information for your application and are also used to bundle together the set of pods created by the deployment.</p>
<p>This exposes port 4567 internally to your namespace. i.e. it enables pods and other objects within your namespace to connect to port 4567 of your container.</p>
<div class="highlight"><pre class="highlight plaintext"><code>apiVersion: v1
kind: Service
metadata:
  name: rubyapp-service
  labels:
    app: rubyapp-service
spec:
  ports:
  - port: 4567
    name: http
    targetPort: 4567
  selector:
    app: helloworld-rubyapp
</code></pre></div><p>The value of <code>spec/selector/app</code> must be the same as <code>spec/template/metadata/labels/app</code> in the <code>deployment.yml</code> file.</p>
<p><em>Tip:</em> You can find more info on service definition in the <a href="https://kubernetes.io/docs/tasks/access-application-cluster/service-access-application-cluster/">kubernetes docs</a>.</p>
<h4 id="ingress-yaml">ingress.yaml</h4><p>Ingress files are to use to define external access to the application.</p>
<p>This creates an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">ingress controller</a> to enable network connections from outside of the cluster.</p>
<p>Note: Because we are specifying <code>http</code>, this ingress controller will expose port 80, and will redirect connections to port 4567 of the named service.</p>
<div class="highlight"><pre class="highlight plaintext"><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: helloworld-rubyapp-ingress
spec:
  rules:
  - host: helloworld-rubyapp.apps.cloud-platform-live-0.k8s.integration.dsd.io
    http:
      paths:
      - path: /
        backend:
          serviceName: rubyapp-service
          servicePort: 4567
</code></pre></div><p>The value of <code>serviceName</code> and <code>servicePort</code> must be the same as those specified in the <code>service.yml</code> file.</p>
<p>Change the <code>helloworld-rubyapp</code> prefix of the <code>host</code> string to the value you want to use as the hostname part of the URL on which your application will be available to the world (do not change the <code>.apps.cloud-platform...</code> part).</p>
<p><em>Tip:</em> You can find more info on ingress in the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">kubernetes docs</a></p>
<h3 id="step-4-deploy-the-application">Step 4 - Deploy the application</h3><p>With all of the deployment files configured, you can now deploy your application to the Cloud Platform.</p>
<p>Start by listing the namespaces on the cluster you are connected to:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl get namespaces
</code></pre></div><p>The list that gets returned should include the one you <a href="/getting-started.html#creating-a-cloud-platform-environment">created earlier</a>, here we assume it is called <code>davids-dummy-dev</code>. Please change that to whatever your namespace (environment) is called, in all of the following commands.</p>
<p>To deploy your application run the following command. This command assumes that the current directory is the root directory of your working copy of the <a href="https://github.com/ministryofjustice/cloud-platform-helloworld-ruby-app">demo application</a>. i.e. <code>kubectl_deploy</code> points to the directory where the deployment files are stored.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl create --filename kubectl_deploy --namespace davids-dummy-dev
</code></pre></div><p>You have to specify the namespace you want to deploy to, this should be the namespace of the environment you created.</p>
<p>Confirm the deployment with:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl get pods --namespace davids-dummy-dev
</code></pre></div><h3 id="interacting-with-the-application">Interacting with the application</h3><p>With the application deployed into the Cloud Platform, there are a few ways of managing it:</p></p>

<ul>
<li><strong>View pods</strong> - <code>kubectl get pods --namespace davids-dummy-dev</code></li>
<li><strong>Check host</strong> - <code>kubectl get ingress --namespace davids-dummy-dev</code></li>
<li><strong>Delete application</strong> - <code>kubectl delete --filename kubectl_deploy --namespace davids-dummy-dev</code></li>
<li><strong>Shell into container</strong> - <code>kubectl exec --stdin --tty --namespace davids-dummy-dev [POD-NAME] -- /bin/sh</code></li>
</ul>

<p>For <code>[POD-NAME]</code> use the value returned by the <code>kubectl get pods...</code> command</p>

<p><em>Tip:</em> You can find more about the <code>kubectl</code> command <a href="https://kubernetes.io/docs/reference/kubectl/overview/">here</a></p>

<p>You should be able to view the app. at the following URL:</p>

<div class="highlight"><pre class="highlight plaintext"><code>  curl -L http://helloworld-rubyapp.apps.cloud-platform-live-0.k8s.integration.dsd.io
</code></pre></div><p>Don&rsquo;t forget to change <code>helloworld-rubyapp</code> to whatever hostname you chose earlier.</p>
<p>Note: You need the <code>-L</code> flag to make curl follow the 308 redirect response that it will receive from the ingress controller. If you view the URL in a web browser, it should just work.</p>

<h2 id="deploying-a-multi-container-application-to-the-cloud-platform">Deploying a multi-container application to the Cloud Platform</h2><h3 id="deploying-a-multi-container-application-to-the-cloud-platform-overview">Overview</h3><p>This section goes through the process of deploying a <a href="https://github.com/ministryofjustice/cloud-platform-multi-container-demo-app">demo application</a> consisting of several components, each running in its own container.</p>
<p>Please see the <a href="https://github.com/ministryofjustice/cloud-platform-multi-container-demo-app##multi-container-demo-application">application README</a> for a description of the different components, and how they connect. You can also run the application locally via docker-compose to confirm that it works as it should.</p>
<h3 id="running-in-the-kubernetes-cluster">Running in the Kubernetes Cluster</h3><p>In the <a href="https://github.com/ministryofjustice/cloud-platform">Cloud Platform</a> kubernetes cluster, the application will be set up like this:</p>
<p><a href="../images/multi-container-k8s.png" target="_blank" rel="noopener noreferrer"><img src="/images/multi-container-k8s.png" alt="Multi-container architecture diagram" /></a></p>
<p>Each container needs a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> which will contain a <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>. <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a> make pods available on the cluster&rsquo;s internal network, and an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> exposes one or more services to the outside world.</p>
<h3 id="create-an-rds-instance">Create an RDS instance</h3><p>The application database will be an Amazon RDS instance. To create this, refer to the <a href="https://github.com/ministryofjustice/cloud-platform-terraform-rds-instance">cloud platform RDS</a> repository, and create a terraform file in your sub-directory of the <a href="https://github.com/ministryofjustice/cloud-platform-environments">cloud platform environments</a> repository (you will need to raise a PR for this, and get the cloud platform team to approve it).</p>
<p>For more information see <a href="/deploying-applications.html#adding-aws-resources-to-your-environment">Adding AWS resources to your environment</a>.</p>
<h3 id="build-docker-images-and-pushing-to-ecr">Build docker images and pushing to ECR</h3><p>As before, we need to build docker images which we will push to our <a href="https://aws.amazon.com/ecr/">Amazon ECR</a>.</p>
<p>Please carry out the following steps on your own working copy of the <a href="https://github.com/ministryofjustice/cloud-platform-multi-container-demo-app">demo application</a>.</p>
<p>For <code>team_name</code> and <code>repo_name</code> please use the values from your <code>ecr.tf</code> file, when you <a href="/getting-started.html#creating-an-ecr-repository">created your ECR</a>.</p>
<div class="highlight"><pre class="highlight plaintext"><code>cd rails-app
docker build -t [team_name]/[repo_name]:rails-app .
docker tag [team_name]/[repo_name]:rails-app 926803513772.dkr.ecr.eu-west-1.amazonaws.com/[team_name]/[repo_name]:rails-app-1.0
docker push 926803513772.dkr.ecr.eu-west-1.amazonaws.com/[team_name]/[repo_name]:rails-app-1.0
</code></pre></div><p>Note that we are overloading the tag value to push multiple different containers to a single Amazon ECR. This is because of a quirk in the way Amazon ECR refers to <code>image repositories</code> and <code>images</code>.</p>
<p>Repeat the steps above for the <code>content-api</code> and <code>worker</code> sub-directories (changing <code>rails-app</code> as appropriate, in the commands).</p>
<p>The <code>makefile</code> in the <a href="https://github.com/ministryofjustice/cloud-platform-multi-container-demo-app">demo application</a> contains commands to make this process easier. Don&rsquo;t forget to edit the values for <code>TEAM_NAME</code>, <code>REPO_NAME</code> and <code>VERSION</code> appropriately.</p>
<h3 id="kubernetes-configuration">Kubernetes configuration</h3><p>As per the diagram, we need to configure six objects in kubernetes - 3 deployments, 2 services and 1 ingress.</p>
<p>You can see these YAML config files in the <code>kubernetes_deploy</code> directory of the <a href="https://github.com/ministryofjustice/cloud-platform-multi-container-demo-app">demo application</a>.</p>
<p>Note: The yaml files in the github repository have the namespace name <code>davids-dummy-dev</code>, team name <code>davids-dummy-team</code> and application name <code>davids-dummy-app</code>. You will need to change these to the corresponding values for your situation, and also the full names of your docker images.</p>
<p>You may also need to change the <code>host</code> entry in the <code>ingress.yaml</code> file, if someone else has deployed an instance of the demo application using the same hostname.</p>
<p>In <code>rails-app-deployment.yaml</code> and <code>worker-deployment.yaml</code> you can see the configuration for two environment variables:</p>

<ul>
<li><code>DATABASE_URL</code> is retrieved from the kubernetes secret which was created when the RDS instance was set up</li>
<li><code>CONTENT_API_URL</code> uses the name and port defined in <code>content-api-service.yaml</code></li>
</ul>
<h3 id="deploying-to-the-cluster">Deploying to the cluster</h3><p>After you have built and pushed your docker images, and made the corresponding changes to the <code>kubernetes_deploy/*.yaml</code> files, you can apply the configuration to your namespace in the kubernetes cluster:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl apply --filename kubernetes_deploy --namespace [your namespace]
</code></pre></div><h3 id="deploying-a-multi-container-application-to-the-cloud-platform-interacting-with-the-application">Interacting with the application</h3><p>You should be able to view the application in your browser at:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  https://multi-container-demo.apps.cloud-platform-live-0.k8s.integration.dsd.io/
</code></pre></div><p>It should behave in the same way as when you were running it locally via docker-compose.</p>

<h2 id="deploying-an-application-to-the-cloud-platform-with-helm">Deploying an application to the Cloud Platform with Helm</h2><h3 id="introduction">Introduction</h3><p>This document will act as a guide to your first application deployment into the Cloud Platform. If you have any issues completing the objective or have any suggestions please feel free to drop use a line in the #ask-cloud-platform slack channel.</p>
<h4 id="objective">Objective</h4><p>By the end of this guide you&rsquo;ll have deployed a reference <a href="https://github.com/ministryofjustice/cloud-platform-reference-app">Django application</a> to a cluster using the Kubernetes package manager <a href="https://helm.sh/">Helm</a>.</p>
<p><em>Disclaimer: You&rsquo;ll see fairly quickly that the application is not fit for production. A perfect example of this is the <a href="https://github.com/ministryofjustice/cloud-platform-reference-app/blob/master/helm_deploy/django-app/templates/secret.yaml">plaintext secrets file</a>. For the reference application we&rsquo;ve left this file in plaintext but it *</em>must** be encrypted when writing your own manifests for production/non-production work in the MoJ.*</p>
<h4 id="requirements">Requirements</h4><p>It is assumed you have the following:</p>

<ul>
<li>You have a basic understanding of what <a href="https://kubernetes.io/">Kubernetes</a> is.</li>
<li>You have <a href="/getting-started.html#creating-a-cloud-platform-environment">created an environment for your application</a></li>
<li>You have installed <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Kubectl</a> on your local machine.</li>
<li>You have <a href="/getting-started.html#authentication">Authenticated</a> to the cloud-platform-live-0 cluster.</li>
</ul>
<h3 id="deploy-the-app">Deploy the app</h3><p>The reference application we&rsquo;re going to use is a very simple Django application with an on-cluster Postgresql database.</p>

<blockquote>
<p>Note: Even though we are going to install a database within the Kubernetes cluster, it is recommended to use a database as a service offering such as <a href="https://aws.amazon.com/rds/">AWS RDS</a> if running in production.</p>
</blockquote>
<p>The Helm deployment manifests have been pre-written for this exercise. But if you wish to know more about these files and what they do have a quick browse of the <a href="https://github.com/ministryofjustice/cloud-platform-reference-app/tree/master/helm_deploy/django-app/README.md">README</a>.</p>
<h4 id="set-up">Set up</h4><p>First we need to clone our reference application and change directory:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ git clone https://github.com/ministryofjustice/cloud-platform-reference-app.git
$ cd cloud-platform-reference-app
</code></pre></div><p>You now have a functioning git repository that contains a simple Django application. Have a browse around and get familiar with the directory structure.</p>
<h4 id="browse-the-cluster">Browse the cluster</h4><p>Let&rsquo;s make use of the command line tool <code>kubectl</code> to browse around the cluster to see what it looks like before we deploy our application:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get pods --namespace &lt;env-name&gt;
</code></pre></div><p><em>The <code>&lt;env-name&gt;</code> here is the environment you created, listed in the requirements section at the beginning of the document.</em></p>
<p>If you receive the below error message then you&rsquo;ve either not typed in your namespace correctly or you don&rsquo;t have permission to perform a <code>get pods</code> command. Either way, you&rsquo;ll need to go back and review the <a href="/getting-started.html#creating-a-cloud-platform-environment">Creating an Environment</a> document previously mentioned.</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ Error from server (Forbidden): pods is forbidden: User "test-user" cannot list pods in the namespace "demo"
</code></pre></div><h4 id="using-helm">Using Helm</h4><p>Helm allows you to manage application deployment to Kubernetes using Charts. You can read about of some of the many features of <a href="https://docs.helm.sh/developing_charts/">Helm Charts</a>. We&rsquo;ve chosen to use Helm as the default way to deploy applications to the Cloud Platform as it provides useful tooling as an interface to the YAML files that Kubernetes uses to run.</p>
<h5 id="tiller-rbac-configuration">Tiller RBAC Configuration</h5><p>There are two parts to Helm: The client and the Helm server (Tiller).</p>
<p>We will create a <code>Service Account</code> resource by adding to your <code>01-rbac.yaml</code> file. This gives Helm the permissions it needs to deploy within your namespace.</p>
<p>Add the following to the bottom of the <code>01-rbac.yaml</code> file you defined when you <a href="/getting-started.html#creating-a-cloud-platform-environment">created your environment</a>:</p>
<div class="highlight"><pre class="highlight plaintext"><code>---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: myapp-dev ## Your namespace `&lt;servicename-env&gt;`
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: tiller
  namespace: myapp-dev ## Your namespace `&lt;servicename-env&gt;`
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myapp-dev ## Your namespace `&lt;servicename-env&gt;`
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
</code></pre></div><p>After you have added this to the file, commit it and create a pull request against the <a href="https://github.com/ministryofjustice/cloud-platform-environments">cloud-platform-environments</a> master repo.</p>
<p>Once it is merged and applied, you will have a service account for Tiller that allows it act on your namespace. Now you have to install Helm and Tiller into your namespace.</p>
<h5 id="installing-and-configuring-helm-and-tiller">Installing and configuring Helm and Tiller</h5><p>Install the client via Homebrew or by other <a href="https://docs.helm.sh/using_helm/##installing-helm">means</a>:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ brew install kubernetes-helm
</code></pre></div><p>Now configure the installation with Tiller:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ helm init --tiller-namespace &lt;env-name&gt; --service-account tiller
</code></pre></div><p>When succesful, you&rsquo;ll be greeted with the message:</p>
<div class="highlight"><pre class="highlight plaintext"><code>Happy Helming
</code></pre></div><p>This is an indication we&rsquo;re ready to deploy our applicaton.</p>
<h5 id="application-install">Application install</h5><p>To deploy the application with Helm first change directory so we can focus on the app we need:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ cd helm_deploy/django-app/
</code></pre></div><p>Values for our application are stored in the <code>values.yaml</code> at the root of our directory. Configurations such as &lsquo;number of pods running&rsquo; and which image repository to use is stored here in this file. Open this file and get familiar with our application layout.</p>
<p>There is an important value in this file called <code>host</code>, which sets the URL for your application. We have to provide this value as an argument on our installation command.</p>
<p>Run the following (replacing the <code>YourName</code> with your own name and <code>env-name</code> with your environment name:</p>
<div class="highlight"><pre class="highlight plaintext"><code>    $ helm install . \
      --name django-app-&lt;YourName&gt; \
      --namespace &lt;env-name&gt; \
      --set deploy.host=django-&lt;YourName&gt;.apps.cloud-platform-live-0.k8s.integration.dsd.io \
      --tiller-namespace &lt;env-name&gt;
</code></pre></div>

<blockquote>
<p>Note: We&rsquo;re naming it like this as app names and host names have to be unique on the cluster.</p>
</blockquote>

<p>The <code>set deploy.host</code> overwrites the value stored in my <code>value.yaml</code> file and you&rsquo;ll see a fairly verbose output showing your pods creating.</p>
<p><h4 id="viewing-your-application">Viewing your application</h4><p>Congratulations on getting this far. If all went well your pods are now deployed and is now being served on your specified URL.</p>
<p>Let&rsquo;s check:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get pods --namespace &lt;env-name&gt;
</code></pre></div><p>If the deploy was successful you should be greeted with something similar to the below:</p>
<div class="highlight"><pre class="highlight plaintext"><code>NAME                                           READY     STATUS    RESTARTS   AGE
django-app-&lt;Name&gt;-fcc657679-w69cr               1/1       Running   1          39m
django-app-&lt;Name&gt;-fcc657679-c5wdm               1/1       Running   1          39m
django-app-&lt;Name&gt;-db-migration-dgnse-qgs7r      0/1       Completed 0          39m
django-app-&lt;Name&gt;-postgresql-7b4bdff4b8-xdlw2   1/1       Running   0          39m
</code></pre></div><p>You should have a postgres pod and 2 app pods <strong>ready</strong> with the status <strong>running</strong>.</p>
<p>(There&rsquo;s also a line for a pod which ran the initial database migrations, but that&rsquo;s completed and no longer running so we&rsquo;ll ignore it.)</p>
<p>Let&rsquo;s check your host has a URL by running:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get ingress --namespace &lt;env-name&gt;
</code></pre></div><p>This will return the URL of your given app. Open it using your favourite browser.</p>
<p>You should be met with an MoJ reference app with the title, <em>&lsquo;Cloud Platforms Deployment&rsquo;</em>. As we mentioned before, there is nothing complicated about this application. You can enter your name and job role, calling the on-cluster postgresql database.</p>
<h4 id="view-the-logs">View the logs</h4><p>Each pod will generate logs that can be viewed via the API. Let&rsquo;s have a browse of our application logs.</p>
<p>First grab the pod name:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get pods --namespace &lt;env-name&gt;
</code></pre></div><p>Then copy the name of a pod that isn&rsquo;t postgresql.</p>
<div class="highlight"><pre class="highlight plaintext"><code>   NAME                                           READY     STATUS    RESTARTS   AGE
 * django-app-&lt;name&gt;-fcc657679-w69cr               1/1       Running   1          54m
   django-app-&lt;name&gt;-fcc657679-c5wdm               1/1       Running   1          39m
   django-app-&lt;name&gt;-postgresql-7b4bdff4b8-xdlw2   1/1       Running   0          54m
</code></pre></div><p>We&rsquo;re going to follow the log, so we&rsquo;ll run:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl logs django-app-&lt;name&gt;-fcc657679-w69cr --namespace &lt;env-name&gt; -f
</code></pre></div><p>As you can see, this tails the log and you should see our health checks giving a HTTP 200.</p>
<p>Read more about Kubernetes logging <a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">here</a>.</p>
<h4 id="scale-the-application">Scale the application</h4><p>You now have our application up and running but you decide two pods aren&rsquo;t enough. Say you want to run three. This is simply a case of changing the replicaCount value in the values.yaml whilst running the <code>helm upgrade</code> command.</p>
<p>Let&rsquo;s try:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ helm upgrade django-app-&lt;YourName&gt; . --set replicaCount=3 --tiller-namespace &lt;env-name&gt; --set deploy.host=&lt;DeploymentURL&gt;
</code></pre></div><p>This command spins up another pod to bring the total number to 3.</p>
<p>If we run the familiar command we&rsquo;ve been using:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get pods --namespace &lt;env-var&gt;
</code></pre></div><p>You&rsquo;ll see the pod replication in progress.</p>
<h4 id="tear-it-all-down">Tear it all down</h4><p>Finally, we have built are app and deployed to the cluster. There is only one thing left to do. Destroy it.</p>
<p>To delete the deployment you simply run:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ helm del --purge django-app-&lt;YourName&gt; --tiller-namespace &lt;env-name&gt;
</code></pre></div><p>And then confirm the pods are terminating as expected:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get pods --namespace &lt;env-var&gt;
</code></pre></div><h3 id="next-steps">Next steps</h3><p>The next step will be to create your own Helm Chart. You can try this with an application of your own or run through <a href="https://docs.bitnami.com/kubernetes/how-to/create-your-first-helm-chart/">Bitnami&rsquo;s excellent guide</a> on how to build using a simple quickstart.</p></p>
<p><h2 id="adding-a-secret-to-an-application">Adding a secret to an application</h2><h3 id="adding-a-secret-to-an-application-overview">Overview</h3><p>The aim of this guide is to walkthrough the process of adding a secret (in this example for aws access-key credentials) to a previously deployed application in the Cloud Platform.</p>
<h3 id="adding-a-secret-to-an-application-prerequisites">Prerequisites</h3><p>This guide assumes the following:</p></p>

<ul>
<li>You have previously set up an env. See <a href="/getting-started.html#creating-a-cloud-platform-environment">Creating a Cloud Platform Environment</a></li>
<li>You have previously deployed your application. See <a href="/deploying-applications.html#deploying-a-39-hello-world-39-application-to-the-cloud-platform">Deploying an application to the Cloud-Platform</a></li>
<li>Check your deployment is running. See <a href="/deploying-applications.html#interacting-with-the-application">Interacting with the application</a></li>
</ul>

<h3 id="configuring-secrets">Configuring secrets</h3><p>The following is an example of encoding (configuring) aws access-key credentials in your deployment.
See <a href="https://kubernetes.io/docs/concepts/configuration/secret/##using-secrets-as-environment-variables">kuberenetes using secrets as environment variables</a></p>
<p>for detailed information regarding providing base64 values in secret objects to Kuberenetes pods)</p>
<p>Create your AWS Credentials access key (making a note of the aws_access_key_id and aws_secret_access_key)</p>
<h4 id="base64-encode-your-secret-as-follows">base64-encode your secret as follows:</h4><p>In this example  aws_access_key_id is &lsquo;AKIAFTKSAW15HJLOGD&rsquo;. Issue the following command to base64-encode:</p>
<div class="highlight"><pre class="highlight plaintext"><code>echo -n 'AKIAFTKSAW15HJLOGD' | base64 -b0
</code></pre></div><p>This will return the encoded id &#39;QUtJQUZUS1NBVzE1SEpMT0dE&rsquo;</p>
<p>In this example the is aws_secret_access_key &#39;g8hjpmhvgfhk4547gfdshhjj&rsquo;. Issue the following command to base64-encode:</p>
<div class="highlight"><pre class="highlight plaintext"><code>echo -n 'QUtJQUZUS1NBVzE1SEpMT0dE' | base64 -b0
</code></pre></div><p>This will return the encoded secret &#39;UVV0SlFVWlVTMU5CVnpFMVNFcE1UMGRF&rsquo;</p>
<h3 id="creating-the-secret">Creating the secret</h3><p>Create a secrets.yaml file similar to:</p>
<div class="highlight"><pre class="highlight plaintext"><code>apiVersion: v1
kind: Secret
metadata:
  name: demosecret
type: Opaque
data:
  aws_access_key_id: QUtJQUZUS1NBVzE1SEpMT0dE
  aws_secret_access_key: UVV0SlFVWlVTMU5CVnpFMVNFcE1UMGRF
</code></pre></div><p>issue the following command:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl apply -f secrets.yaml
secret "demosecret" created
</code></pre></div><p>To see the secrets:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get secrets
NAME                                          TYPE                                  DATA      AGE
calico-zebu-external-dns-token-pldjb          kubernetes.io/service-account-token   3         16d
dandy-bumblebee-nginx-ingress-token-bspl6     kubernetes.io/service-account-token   3         14d
default-token-hz7z7                           kubernetes.io/service-account-token   3         26d
demosecret                                    Opaque                                2         5d
</code></pre></div><p>Decoding the Secret
Secrets can be retrieved via the kubectl get secret command. For example, to retrieve the secret you created:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ kubectl get secret demosecret  -o yaml
apiVersion: v1
data:
  aws_access_key_id: dGVzdCBrZXk=
  aws_secret_access_key: dGVzdCBrZXk=
kind: Secret
metadata:
  creationTimestamp: 2018-05-15T12:24:33Z
  name: demosecret
</code></pre></div><p>Add the AWS_ACCESS_KEY_ID referencing &#39;aws_access_key_id&rsquo; and AWS_SECRET_ACCESS_KEY referencing &#39;aws_secret_access_key&rsquo; (as previously set) to the containers env in <code>deployment-files/deployment.yaml</code></p>
<div class="highlight"><pre class="highlight plaintext"><code>    spec:
      containers:
        - name: django-demo-container
          image: 926803513772.dkr.ecr.eu-west-1.amazonaws.com/cloud-platform-reference-app:django
          ports:
            - containerPort: 8000
          env:
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: demosecret
                  key: aws_access_key_id
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: demosecret
                  key: aws_secret_access_key
</code></pre></div>
<h2 id="continuous-deployment-of-an-application-using-circleci-and-helm">Continuous Deployment of an application using CircleCI and Helm</h2><h3 id="continuous-deployment-of-an-application-using-circleci-and-helm-introduction">Introduction</h3><p>This document covers how to continuously deploy your application in the Cloud Platform. It is essentially a continuation of <a href="/deploying-applications.html#deploying-an-application-to-the-cloud-platform-with-helm">‘Deploying an application to the Cloud Platform with Helm’</a>.</p>
<p><em>Note: This document is specific to using <a href="https://circleci.com/">CircleCI</a> as the Continuous Integration method.</em></p>
<h4 id="continuous-deployment-of-an-application-using-circleci-and-helm-introduction-objective">Objective</h4><p>By the end of the tutorial, you will have done the following:</p>

<ul>
<li>Created a Service Account for CircleCI in your namespace</li>
<li>Generated a CircleCI configuration file in your application repository. The configuration file will authenticate with your chosen cluster, build a docker image and push it to ECR and upgrade your helm deployment with the new docker image.</li>
<li>Have an automated CircleCI pipeline that upgrades your helm deployment when a new change is pushed to your master branch</li>
</ul>
<h4 id="continuous-deployment-of-an-application-using-circleci-and-helm-introduction-requirements">Requirements</h4><p>It is assumed you have the following:</p>

<ul>
<li>You have <a href="/getting-started/env-create">created an environment for your application</a></li>
<li>You have <a href="/deploying-applications.html#deploying-an-application-to-the-cloud-platform-with-helm">deployed an application</a> to the &lsquo;cloud-platform-live-0&rsquo; cluster using Helm.</li>
<li>You have created an <a href="/getting-started.html#creating-an-ecr-repository">ECR repository</a></li>
</ul>
<h4 id="creating-a-service-account-for-circleci">Creating a Service Account for CircleCI</h4><p>As part of the CircleCI deployment pipeline, CircleCI will need to authenticate with the Kubernetes cluster. In order to do so, Kubernetes uses <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Service Accounts</a>. Service Accounts provide an identity for processes that run in a cluster allowing the process to access the API server.</p>
<p>A Service Account is created in the <a href="https://github.com/ministryofjustice/cloud-platform-environments/tree/master/namespaces">namespace creation github repository</a>.
&ldquo;`bash
  $ kubectl get serviceaccounts &ndash;namespace $ns
  NAME       SECRETS   AGE
  circleci   1         3h</p>
<p>$ kubectl get serviceaccounts/circleci &ndash;namespace reference-app -o yaml
  apiVersion: v1
  kind: ServiceAccount
  &hellip;
  secrets:
  - name: circleci-token-prlkp</p>
<p>$ kubectl get secrets &ndash;namespace $ns
  NAME                   TYPE                                  DATA      AGE
  circleci-token-prlkp   kubernetes.io/service-account-token   3         3h</p>
<p>$ kubectl get secrets/circleci-token-prlkp &ndash;namespace $ns -o yaml
  &hellip;
  namespace: cm..cA==
  token: ZX&hellip;EE=
&rdquo;`</p>
<h4 id="linking-repository-to-circleci">Linking Repository to CircleCI</h4><p>MoJ has as an account with CircleCI, please login to <a href="https://circleci.com/dashboard">CircleCI</a> using GitHub credentials. Select project, and if config.yml is in the repo CircleCI will build and run tests.</p>
<h4 id="add-variables-to-circleci">Add variables to CircleCI</h4><p>There is a number of environment variables that you will need to set on your CircleCI project in order to build a docker image, push it to the ECR and trigger a deployment in your environment. On the project page, click the cog icon in the top right corner and select <code>Enviroment Variables</code> under <code>Build Settings</code>. The variables you will need to set are listed below.</p>
<h5 id="aws-credentials">AWS credentials</h5><p>To authenticate with ECR, you will need to set:
- <code>AWS_DEFAULT_REGION</code> - would be <code>eu-west-1</code> for Cloud Platform clusters unless specified otherwise
- <code>AWS_ACCESS_KEY_ID</code>
- <code>AWS_SECRET_ACCESS_KEY</code>
- <code>ECR_ENDPOINT</code> is optional but useful if you want to avoid having to hardcode the full hostname of the registry</p>
<h5 id="kubernetes-serviceaccount-credentials">Kubernetes <code>ServiceAccount</code> credentials</h5><p>Since a single CircleCI project will need to access multiple namespaces in kubernetes (the environments), it will also need to handle multiple credentials. To simplify authentication, we provide a helper script in our supported <a href="https://github.com/ministryofjustice/cloud-platform-tools-image">build image</a>. For a usage example, see <a href="##upload-to-ecr">Deploy To Kubernetes</a> below.</p>
<p>There are four different variables that CircleCI will need to access <em>per environment</em>. Our helper script expects environment variables to be named according to the list below where <code>&lt;ENVIRONMENT&gt;</code> should be replaced by some identifier of your choosing (eg.: <code>STAGING</code>, <code>PRODUCTION</code>).
- <code>KUBE_ENV_&lt;ENVIRONMENT&gt;_NAME</code> - the full name of the cluster (eg.: <code>cloud-platform-live-0.k8s.integration.dsd.io</code>)
- <code>KUBE_ENV_&lt;ENVIRONMENT&gt;_NAMESPACE</code> - the name of the <code>Namespace</code> (see <a href="/getting-started.html#creating-a-cloud-platform-environment">Create a namespace</a>)
- <code>KUBE_ENV_&lt;ENVIRONMENT&gt;_CACERT</code> - the CA Certificate for the cluster, can be acquired from the <code>Secret</code> that is generated for the <code>ServiceAccount</code>
- <code>KUBE_ENV_&lt;ENVIRONMENT&gt;_TOKEN</code> - the access token generated for the <code>ServiceAccount</code>. Please note, you should first base64 decode the token value you retrieve from the secret <a href="##creating-a-service-account-for-circleci">in the previous section</a>, e.g. <code>echo &lt;thereallylongstringthatyougetback&gt; | base64 --decode</code>.</p>
<h4 id="creating-the-config-yml">Creating the config.yml</h4><p>CircleCI uses a YAML file to identify how you want your testing environment set up and what tests you want to run. On CircleCI 2.0, this file must be called <code>config.yml</code> and must be in a hidden folder called <code>.circleci</code> .</p>
<p><a href="https://circleci.com/docs/2.0/tutorials/">Tutorial</a> on creating a config.yml file. As long as you are building a Docker image you can configure Circle however you wish. The only additional configuration you will need to add is to upload an image to ECR and deploy to Kubernetes:</p>
<h5 id="upload-to-ecr">Upload to ECR</h5><p>Example of how you can push a built docker image to an ECR repository:</p>
<div class="highlight"><pre class="highlight yaml"><code><span class="pi">-</span> <span class="na">deploy</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">Push application Docker image</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="no">$(aws ecr get-login --no-include-email)</span>
      <span class="no">docker tag app "${ECR_ENDPOINT}/${GITHUB_TEAM_NAME_SLUG}/${CIRCLE_PROJECT_REPONAME}:${CIRCLE_SHA1}"</span>
      <span class="no">docker push "${ECR_ENDPOINT}/${GITHUB_TEAM_NAME_SLUG}/${CIRCLE_PROJECT_REPONAME}:${CIRCLE_SHA1}"</span>
      <span class="no">if [ "${CIRCLE_BRANCH}" == "master" ]; then</span>
        <span class="no">docker tag app "${ECR_ENDPOINT}/${GITHUB_TEAM_NAME_SLUG}/${CIRCLE_PROJECT_REPONAME}:latest"</span>
        <span class="no">docker push "${ECR_ENDPOINT}/${GITHUB_TEAM_NAME_SLUG}/${CIRCLE_PROJECT_REPONAME}:latest"</span>
      <span class="no">fi</span>
</code></pre></div><h5 id="deploy-to-kubernetes">Deploy to Kubernetes</h5><p>We provide a docker image that simplifies the CircleCI configuration by encapsulating the authentication process in a script. For example, given a configured <code>DEVELOPMENT</code> environment (see the section on environment variables above):</p>
<div class="highlight"><pre class="highlight yaml"><code><span class="na">deploy_development</span><span class="pi">:</span>
  <span class="na">docker</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">${ECR_ENDPOINT}/cloud-platform/tools:circleci</span>
  <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">checkout</span>
    <span class="pi">-</span> <span class="na">deploy</span><span class="pi">:</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Helm deployment</span>
        <span class="na">command</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="no">setup-kube-auth</span>
          <span class="no">kubectl config use-context development</span>
          <span class="no">if [ "${CIRCLE_BRANCH}" == "master" ]; then</span>
            <span class="no">helm upgrade ${APPLICATON_DEPLOY_NAME} ./helm_deploy/django-app/. \</span>
                          <span class="no">--install \</span>
                          <span class="no">--tiller-namespace=${NON_PROD_NS} \</span>
                          <span class="no">--namespace=${NON_PROD_NS} \</span>
                          <span class="no">--set image.repository="${ECR_ENDPOINT}/${GITHUB_TEAM_NAME_SLUG}/${CIRCLE_PROJECT_REPONAME}" \</span>
                          <span class="no">--set image.tag="latest" \</span>
                          <span class="no">--set deploy.host="${APPLICATION_HOST_URL}" \</span>
                          <span class="no">--set replicaCount="4" \</span>
                          <span class="no">--debug</span>
          <span class="no">fi</span>
</code></pre></div>
<h2 id="adding-aws-resources-to-your-environment">Adding AWS resources to your environment</h2><p>Through the <a href="https://github.com/ministryofjustice/cloud-platform-environments/">cloud-platform-environments</a> repository, you can provision AWS resources for your environments. This is done using terraform and more specifically, terraform modules we provide for use on the Cloud Platform.</p>
<p>The documentation for the modules lives in each module&rsquo;s repository and you can find a list of the available ones below.</p>
<h3 id="available-modules">Available modules</h3>

<ul>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-ecr-credentials">ECR Repository</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-s3-bucket">S3 Bucket</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-rds-instance">RDS instance</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-elasticache-cluster">Elasticache Redis Cluster</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-dynamodb-cluster">DynamoDB Table</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-sns-topic">SNS Topic</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-sqs">SQS Queue</a></li>
<li><a href="https://github.com/ministryofjustice/cloud-platform-terraform-amq-broker">MQ Broker</a></li>
</ul>
<p><h3 id="usage">Usage</h3><p>In each terraform module repository, you will find a directory named <code>example</code> which includes sample configuration for use in Cloud Platform.</p>
<p>In your namespace&rsquo;s path in the <a href="https://github.com/ministryofjustice/cloud-platform-environments/">cloud-platform-environments</a> repository, create a directory called <code>resources</code> (if you have not created one already) and refer to the module&rsquo;s example to define your resources.</p>
<p>Each example will have some global configuration defined, however, this should only be declared once, regardless of the number of modules used:</p>
<div class="highlight"><pre class="highlight plaintext"><code>terraform {
  backend &quot;s3&quot; {}
}</p>
<p>provider &quot;aws&quot; {
  region = &quot;eu-west-1&quot;
}
</code></pre></div><p>Additionally, some example might define variables; again, these should only be declared once per namespace:</p>
<div class="highlight"><pre class="highlight plaintext"><code>variable &quot;cluster_name&quot; {}</p>
<p>variable &quot;cluster_state_bucket&quot; {}
</code></pre></div><p>The main README file of each module repository will list all the available configuration options that can be passed to the module.</p>
<h4 id="outputs">Outputs</h4><p>Each module will have its own outputs. These expose useful information, such as endpoints, credentials etc. The module examples all use a common approach: they employ the <code>kubernetes_secret</code> terraform resource to push the outputs straight into your environment in the form of a <code>Secret</code> which you could then extract information from or directly reference in <code>Pods</code>.</p>
<p>This is currently the only supported way of accessing terraform outputs.</p>
<h4 id="versioning">Versioning</h4><p>All modules are versioned. This allows us to implement changes without breaking existing resources. To use a specific version of a module you need to define it in the <code>source</code> attribute by specifying the <code>ref</code> attribute in the query string of the source URL:</p>
<div class="highlight"><pre class="highlight plaintext"><code>module &quot;my_module&quot; {
  source = &quot;https://github.com/ministryofjustice/cloud-platform-terraform-ecr-credentials?ref=1.0&quot;
}
</code></pre></div><p>Make sure that you have checked the releases page of a module and that you are using the latest of them in your configuration.</p>
<p>Upgrading to a new major version usually means that the configured resource will have to be re-created by terraform.</p>
<p>Refer to the <a href="http://terraform.io/docs/modules">terraform documentation on modules</a> for more information on usage.</p></p>
<p><h2 id="cleaning-up">Cleaning up</h2><p>When you have finished working with your initial deployment, please clean up the resources you have created. This helps to keep the cloud platform repositories well-organised, and speeds up deployments and changes to the cluster (because the build process doesn&rsquo;t have to spend time managing unnecessary resources). It also helps to keep our hosting costs down.</p>
<p>The resources to be removed are:</p></p>

<ul>
<li>The ECR which stores your docker images</li>
<li>Your namespace in the cluster. This contains all of the pods, containers and other cluster resources for your application. Removing the cluster namespace will automatically clean up all of its contents.</li>
</ul>
<p><h3 id="removing-resources-from-your-namespace">Removing resources from your namespace</h3><p>Do this if you want to empty your namespace, e.g. to reuse it for another section of the user guide, or to experiment for yourself. You do not need to do this if you are removing the whole namespace - any contents will be deleted automatically, in that case.</p>
<h4 id="the-safe-way">The safe way</h4><p>Use <code>kubectl get ...</code> commands to identify the different resources in your namespace, e.g.</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl get deployment helloworld-rubyapp --namespace [your namespace]
  kubectl get service rubyapp-service --namespace [your namespace]
  kubectl get ingress helloworld-rubyapp-ingress --namespace [your namespace]
</code></pre></div><p>Then, once you have identified the resources running in your namespace, use <code>kubectl delete</code> to delete them:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl delete deployment helloworld-rubyapp --namespace [your namespace]
  kubectl delete service rubyapp-service --namespace [your namespace]
  kubectl delete ingress helloworld-rubyapp-ingress --namespace [your namespace]
</code></pre></div><p>You can find more information about <code>kubectl</code> <a href="https://kubernetes.io/docs/reference/kubectl/overview/">here</a>.</p>
<h4 id="the-quicker-less-safe-way">The quicker, less safe way</h4><p>If you are confident that your kubernetes deployment files accurately map to the resources running in your cluster, you can delete everything at once like this:</p>
<div class="highlight"><pre class="highlight plaintext"><code>  kubectl delete --filename kubernetes_deploy --namespace [your namespace]
</code></pre></div><p>This is analogous to using <code>kubectl apply</code> to create the resources from your YAML files, but it will delete all the named resources.</p>
<h3 id="removing-your-ecr">Removing your ECR</h3><p>Your <a href="https://aws.amazon.com/ecr/">ECR</a> was created by adding an <code>ecr.tf</code> file to the Cloud Platform <a href="https://github.com/ministryofjustice/cloud-platform-environments">environments repository</a>.</p>
<p>To delete your ECR, once you no longer need it, requires two steps:</p></p>

<ol>
<li>Remove the <code>ecr.tf</code> file from the <a href="https://github.com/ministryofjustice/cloud-platform-environments">environments repository</a>. This prevents the ECR from being automatically recreated the next time the cluster configuration is applied.</li>
<li>A cluster administrator needs to manually delete the ECR (either via the Amazon AWS web console, or using the <a href="https://aws.amazon.com/cli/">AWS CLI</a>.</li>
</ol>
<p><h3 id="removing-your-namespace">Removing your namespace</h3><p>Namespaces are created by adding YAML config files to the Cloud Platform <a href="https://github.com/ministryofjustice/cloud-platform-environments">environments repository</a>.</p>
<p>To delete a namespace requires two steps:</p></p>

<ol>
<li>Remove the YAML config files from the <a href="https://github.com/ministryofjustice/cloud-platform-environments">environments repository</a>. This prevents the namespace from being automatically recreated the next time the cluster configuration is applied.</li>
<li>A cluster administrator needs to run a <code>kubectl delete namespace [name of the namespace]</code> command to delete the namespace and its contents.</li>
</ol>
<p><h3 id="raising-a-pull-request">Raising a pull request</h3><p>When you have finished with your sandbox namespace, and its associated ECR, please create a branch of the <a href="https://github.com/ministryofjustice/cloud-platform-environments">environments repository</a> with your environment&rsquo;s sub-directory of the <code>namespaces/cloud-platform-live-0.k8s.integration.dsd.io</code> directory removed, and raise a <a href="https://help.github.com/en/articles/about-pull-requests">pull request</a> to merge your branch into master. Once merged, this will remove the YAML files which define your namespace, and also the <code>ecr.tf</code> file which defines your ECR.</p>
<p>In the body of your PR, please add a note to ask the cloud platform team to manually delete both your namespace and your ECR.</p></p>


            
          </main>

            <ul class="contribution-banner">
              <li><a href="https://github.com/ministryofjustice/cloud-platform-user-guide/blob/master/source/deploying-applications.html.md.erb">View source</a></li>
              <li><a href="https://github.com/ministryofjustice/cloud-platform-user-guide/issues/new?labels=bug&amp;title=Re:%20'Deploying%20Applications'&amp;body=Problem%20with%20'Deploying%20Applications'%20(https://user-guide.cloud-platform.service.justice.gov.uk/deploying-applications.html)">Report problem</a></li>
              <li><a href="https://github.com/ministryofjustice/cloud-platform-user-guide">GitHub Repo</a></li>
            </ul>

          <footer class="footer">
  <div class="footer__licence">
    <a class="footer__licence-logo" href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" rel="license">Open Government Licence</a>
    <p class="footer__licence-description">All content is available under the <a href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" rel="license">Open Government Licence v3.0</a>, except where otherwise stated</p>
  </div>

  <div class="footer__copyright">
    <a class="footer__copyright-logo" href="http://www.nationalarchives.gov.uk/information-management/re-using-public-sector-information/copyright-and-re-use/crown-copyright/">© Crown copyright</a>
  </div>
</footer>

        </div>
      </div>
    </div>

    
  </body>
</html>
